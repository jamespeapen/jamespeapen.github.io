[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a 5th-year PhD student in the Shen lab at Van Andel Institute. I work on developing tools to study DNA methylation and chromatin architecture in Fallopian tube."
  },
  {
    "objectID": "posts/vimmy/index.html",
    "href": "posts/vimmy/index.html",
    "title": "vimmy",
    "section": "",
    "text": "Once you learn vim and develop muscle memory for its key bindings, its quite hard to go back to a text editor without them. Emulators in other text editors don’t generally implement enough of vim’s functionality for a smooth transition and using them can be a little jarring after spending hours in a vim buffer, especially if you’ve got a specialized configuration.\nI use firenvim for my browser to get a neovim buffer and some plugins in any text box. This is nice when I have to use a browser for email, Github, and Slack/Teams. However, when I need to write with other people, writing a response to reviewers after peer-review for example, I find myself forced to use Word online which does not use a standard text-input box for text entry. Word online is particularly frustrating because, for reasons I don’t understand, it loses text after I type. I could write a whole paragraph and hit retrun only to lose all but the first few words I wrote.\nMy solution, partially inspired by tools like that bring a vim buffer where you are, was to launch a temporary vim buffer, write in it, and when I save and close the buffer, the vim and its container terminal window close and what I just wrote is typed into the vim-unfriendly buffer that I just had to deal with.\nThe first problem was an extra newline getting added when catting the file. I found a solution using perl that ‘chomps’ the final newline to remove it. Then the issue was getting it into the original editor. I tried to paste it but couldn’t find a way to programmatically paste with xclip since xclip -o calls only paste into the calling terminal window. So I turned to xdotool to type it out. This worked but lost all newlines. I then figured out how to preserve newlines by translating the linefeed (LF) \\n character to the carriage return (CR) \\r character. https://unix.stackexchange.com/questions/399403/xdotools-type-mangles-carriage-returns\n#! /usr/bin/env zsh\n\nkitty --class flykitty \\\nnvim \\\n  -c 'set laststatus=0' \\\n  -c 'set spell' \\\n  -c 'source ~/.config/nvim/vim/autocorrect.vim' /tmp/temp_buffer\n\nperl -pe 'chomp if eof' /tmp/temp_buffer |\\\n  tr \\\\n \\\\r |\\\n  xdotool type --delay 0.5 -file -\nthe window has the ‘flykitty’ class because my i3 settings float every window of class ‘flykitty’ instead of tiling it\nThis script launches neovim in a kitty window with spell check and autocorrect, but without a status bar. Once saved, kitty exits and the output file is processed and typed out wherever my cursor focus was before launching the script."
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software",
    "section": "",
    "text": "An R package to analyse Seahorse data.\n                       \n\n\n\nAn R package to query and summarize BED files fast\n\n\n\n\nAn R package to infer chromatin compartments from scRNA/scATAC data."
  },
  {
    "objectID": "software.html#r",
    "href": "software.html#r",
    "title": "Software",
    "section": "",
    "text": "An R package to analyse Seahorse data.\n                       \n\n\n\nAn R package to query and summarize BED files fast\n\n\n\n\nAn R package to infer chromatin compartments from scRNA/scATAC data."
  },
  {
    "objectID": "posts/renv_flake.html",
    "href": "posts/renv_flake.html",
    "title": "Nix flakes with renv",
    "section": "",
    "text": "I’ve been using Nix-based development environments for my projects for the last two years to declaratively install dependencies and define environment variables. Installing packages, from both nixpkgs and source, is reproducible. Making modifications like compiling something with an optional dependency or applying patches is easy. With direnv, you get a pseudo-container every time you enter the project directory with all software and variables available. Recently I’ve started using Nix flakes to set up and maintain the tools I need, all off one nixpkgs commit with versions locked by flake.lock. Non-nix systems don’t have such an easy and declarative way to lock dependencies, especially across languages or toolchains.\nFor this site, I use a flake to develop locally and an ubuntu runner on Github actions for deployment. I wanted to use the same R and package versions both locally and on the action runner to ensure that what works on my system works on Github. renv is the standard way to produce lockfiles in R but, since it’s normal operation requires initializing a project and installing the packages outside nix, I didn’t think I could use it. I found nix-based actions exist, but they are slower than installing R and the packages directly because they need to set up nix first.\nGoing back to renv’s documentation, I found lockfile_create(), a function for programmatic renv operations. Using .libPaths(), it create lockfiles from installed packages. Since R packages installed with nix are conveniently added to .libPaths() running lockfile_create() in a flake shell produces the required lockfile. However, since it doesn’t produce any output or write files, it took me a while to figure out that lockfile_write() takes lockfile_create() to produce renv.lock.\nAdding this to a shell hook writes the renv.lock file on flake activation. To avoid running this every time I activate the environment, the shell hook only runs renv commands if renv.lock is older than either flake.nix (if adding or removing packages) or flake.lock (for updates). Every update of the flake will update the package versions in both the nix shell environment and the renv lockfile, controlling both the nix and the renv environments with just the flake.\n...\ndevShells.default = pkgs.mkShell {\n  buildInputs = [ inputs ];\n  shellHook = ''\n      if [[ flake.nix -nt renv.lock ]] || [[ flake.lock -nt renv.lock ]]; then\n        R -q -e \"renv::lockfile_write(renv::lockfile_create())\"\n      fi\n  '';\n}\n...\nUntil Github gets a NixOS runner, this should keep my R-nix dependencies locked and declaratively managed."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Nix flakes with renv\n\n\n\n\n\n\nR\n\nnix\n\n\n\n\n\n\n\n\n\nJul 7, 2025\n\n\nJames Eapen\n\n\n\n\n\n\n\n\n\n\n\n\nvimmy\n\n\nWill type outside vim so you don’t have to\n\n\n\ndotfiles\n\ncli\n\nvim\n\n\n\n\n\n\n\n\n\nJul 5, 2025\n\n\nJames Eapen\n\n\n\n\n\nNo matching items"
  }
]