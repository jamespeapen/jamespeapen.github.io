[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a 5th-year PhD student in the Shen lab at Van Andel Institute. I work on developing tools to study DNA methylation and chromatin architecture in Fallopian tube."
  },
  {
    "objectID": "posts/vimmy/index.html",
    "href": "posts/vimmy/index.html",
    "title": "vimmy",
    "section": "",
    "text": "Once you learn vim and develop muscle memory, its quite hard to go back to a text editor that doesn’t have vim bindings. If you have a very customized set of vim bindings, the emulators available in certain text editors don’t do enough and can still be annoying.\nMy solution, partially inspired by tools like firenvim that bring a vim buffer where you are, was to launch a temporary vim buffer, write in it, and when I save and close the buffer, the vim and its container terminal window close and what I just wrote is typed into the vim-unfriendly buffer that I just had to deal with.\nThe first problem was an extra newline getting added when catting the file. I found a solution using perl that ‘chomps’ the final newline to remove it. Then the issue was getting it into the original editor. I tried to paste it but couldn’t find a way to programmatically paste - any xclip -o call only pasted into the calling terminal window. So I turned to xdotool to type it out. This worked but lost all newlines. I figured out how to preserve newlines by translating the linefeed (LF) \\n character to the carriage return (CR) \\r character. https://unix.stackexchange.com/questions/399403/xdotools-type-mangles-carriage-returns\n#! /usr/bin/env zsh\n\nkitty --class flykitty \\\nnvim \\\n  -c 'set laststatus=0' \\\n  -c 'set spell' \\\n  -c 'source ~/.config/nvim/vim/autocorrect.vim' /tmp/temp_buffer\n\nperl -pe 'chomp if eof' /tmp/temp_buffer |\\\n  tr \\\\n \\\\r |\\\n  xdotool type --delay 0.5 -file -\nThis script launches neovim in a kitty window  with spell check and autocorrect, but without a status bar. Once saved, kitty exits and the output file is processed and typed out.the window has the ‘flykitty’ class because my i3 settings float every window of class ‘flykitty’ instead of tiling it"
  },
  {
    "objectID": "posts/spotlight/index.html",
    "href": "posts/spotlight/index.html",
    "title": "spotlight",
    "section": "",
    "text": "When I started my PhD, my school gave me a MacBook Pro from 2019/20 that I used for my first year. I later got a Thinkpad from my lab since I missed the more easily customizable Linux experience. However, I liked, to a degree, the MacOS spotlight app to search your system for files which could be bound to a keyboard shortcut. I wanted something similar but better for linux that could search for and open files.\nI started with fzf which provides a powerful way to create a command line interface. Along with fd, it provides a very fast and flexible way to search your system.\n#! /usr/bin/env bash\nexport FD_COMMAND=\"fd -L --no-ignore-vcs\"\nexport FD_NOIGNORE=\"fd -L --no-ignore\"\nexport FZF_DEFAULT_COMMAND=\"$FD_COMMAND\"\nThese variables setup two fd commands, the first ignores files in the global fd ignore file while the second ignores nothing.\n# bindings\nexport RELOAD=\"ctrl-r\"             # reload interface and search\nexport IGNORE=\"alt-i\"              # don't ignore globally ignored\nexport SEL=\"ctrl-i\"                # toggle line selection \nexport SEL_ALL=\"alt-a\"             # select all results\nexport DESEL_ALL=\"alt-A\"           # deselect all results\nexport SEARCH_DIRS=\"ctrl-d\"        # filter to directories\nexport SEARCH_FILES=\"ctrl-f\"       # filter to files\nexport DELETE=\"alt-r\"              # delete file (with confirmation)\nexport XDRAGON=\"ctrl-t\"            # send file to xdragon\nexport TOGGLE_SORT=\"ctrl-s\"        # toggle fzf sorting mechanism\nexport COPY_PATH=\"ctrl-y\"          # copy the filepath to clipboard\nexport TOGGLE_PREVIEW=\"ctrl-space\" # toggle the preview pane\nexport PREVIEW_DOWN=\"alt-d\"        # scroll preview down\nexport PREVIEW_UP=\"alt-u\"          # scroll preview up\nexport CLEAR_IMG=\"ctrl-/\"          # clear shown images\nfzf allows running commands or changing the interface using keybindings.\nfiles=$(fzf \\\n    --extended \\                        # extended search mode\n    --multi \\                           # \n    --border \\                          #\n    --padding 1 \\                       #\n    --prompt \"Search&gt; \" \\               #\n    --ghost \"filename .ext 'exact \" \\\n    --bind change:first \\\n    --bind \"$RELOAD:change-prompt(Search&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$IGNORE:reload($FD_NOIGNORE)\" \\\n    --bind \"$SEL:toggle-out\" \\\n    --bind \"$SEL_ALL:select-all\" \\\n    --bind \"$DESEL_ALL:deselect-all\" \\\n    --bind \"$SEARCH_DIRS:change-prompt(Directories only&gt; )+reload(fd -L --type d)+execute(kitty icat --clear)\" \\\n    --bind \"$SEARCH_FILES:change-prompt(Files only&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$RELOAD:change-prompt(Search&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$DELETE:execute(rm -i {})+reload($FD_COMMAND)\" \\\n    --bind \"$XDRAGON:become(setsid -f dragon -x -a {+} && kill \\\"$$\\\")\" \\\n    --bind \"$TOGGLE_SORT:toggle-sort\" \\\n    --bind \"$COPY_PATH:become(timeout 1s xclip -se c &lt;(realpath {}) && kill \\\"$$\\\")\" \\\n    --bind \"$TOGGLE_PREVIEW:toggle-preview+execute(kitty icat --clear)\" \\\n    --bind \"$PREVIEW_DOWN:preview-down\" \\\n    --bind \"$PREVIEW_UP:preview-up\" \\\n    --bind \"$CLEAR_IMG:change-preview-window(hidden)+execute(kitty icat --clear)\" \\\n    --header \"$DESEL_ALL/A: Select/deselect all | $SEARCH_DIRS: Search dirs | $SEARCH_FILES: Search files | $XDRAGON: Open with xdragon | $TOGGLE_PREVIEW: toggle preview | $CLEAR_IMG: clear images\" \\\n    --preview-window hidden \\\n    --preview \"\n        if file --mime-type {} | grep -qF 'image/'; then\n           kitty icat --clear --transfer-mode=stream --stdin=no --place=\\${FZF_PREVIEW_COLUMNS}x\\${FZF_PREVIEW_LINES}@0x0 {}\n        elif file --mime-type {} | grep -qF 'text/csv'; then\n          csview {}\n        elif file --mime-type {} | grep -qF 'inode/directory'; then\n           eza --tree --color --icons {}\n        elif file --mime-type {} | grep -qF 'inode/directory'; then\n           eza --tree --color --icons {}\n        else\n          bat --color=always {}\n        fi\n    \"\n)\necho \"$files\"\nfor file in $files; do\n    setsid -f xdg-open $file\ndone\n\n\nFull script\n\n#! /usr/bin/env bash\nexport FD_COMMAND=\"fd -L --no-ignore-vcs\"\nexport FD_NOIGNORE=\"fd -L --no-ignore\"\nexport FZF_DEFAULT_COMMAND=\"$FD_COMMAND | sed 's/^.\\///'\"\n# bindings\nexport RELOAD=\"ctrl-r\"\nexport IGNORE=\"alt-i\"\nexport SEL=\"ctrl-i\"\nexport SEL_ALL=\"alt-a\"\nexport DESEL_ALL=\"alt-A\"\nexport SEARCH_DIRS=\"ctrl-d\"\nexport SEARCH_FILES=\"ctrl-f\"\nexport DELETE=\"alt-r\"\nexport XDRAGON=\"ctrl-t\"\nexport TOGGLE_SORT=\"ctrl-s\"\nexport COPY_PATH=\"ctrl-y\"\nexport TOGGLE_PREVIEW=\"ctrl-space\"\nexport PREVIEW_DOWN=\"alt-d\"\nexport PREVIEW_UP=\"alt-u\"\nexport CLEAR_IMG=\"ctrl-/\"\nfiles=$(fzf \\\n    --extended \\\n    --multi \\\n    --border \\\n    --padding 1 \\\n    --prompt \"Search&gt; \" \\\n    --ghost \"filename .ext 'exact \" \\\n    --bind change:first \\\n    --bind \"$RELOAD:change-prompt(Search&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$IGNORE:reload($FD_NOIGNORE)\" \\\n    --bind \"$SEL:toggle-out\" \\\n    --bind \"$SEL_ALL:select-all\" \\\n    --bind \"$DESEL_ALL:deselect-all\" \\\n    --bind \"$SEARCH_DIRS:change-prompt(Directories only&gt; )+reload(fd -L --type d)+execute(kitty icat --clear)\" \\\n    --bind \"$SEARCH_FILES:change-prompt(Files only&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$RELOAD:change-prompt(Search&gt; )+reload($FD_COMMAND)\" \\\n    --bind \"$DELETE:execute(rm -i {})+reload($FD_COMMAND)\" \\\n    --bind \"$XDRAGON:become(setsid -f dragon -x -a {+} && kill \\\"$$\\\")\" \\\n    --bind \"$TOGGLE_SORT:toggle-sort\" \\\n    --bind \"$COPY_PATH:become(timeout 1s xclip -se c &lt;(realpath {}) && kill \\\"$$\\\")\" \\\n    --bind \"$TOGGLE_PREVIEW:toggle-preview+execute(kitty icat --clear)\" \\\n    --bind \"$PREVIEW_DOWN:preview-down\" \\\n    --bind \"$PREVIEW_UP:preview-up\" \\\n    --bind \"$CLEAR_IMG:change-preview-window(hidden)+execute(kitty icat --clear)\" \\\n    --header \"$DESEL_ALL/A: Select/deselect all | $SEARCH_DIRS: Search dirs | $SEARCH_FILES: Search files | $XDRAGON: Open with xdragon | $TOGGLE_PREVIEW: toggle preview | $CLEAR_IMG: clear images\" \\\n    --preview-window hidden \\\n    --preview \"\n        if file --mime-type {} | grep -qF 'image/'; then\n           kitty icat --clear --transfer-mode=stream --stdin=no --place=\\${FZF_PREVIEW_COLUMNS}x\\${FZF_PREVIEW_LINES}@0x0 {}\n        elif file --mime-type {} | grep -qF 'text/csv'; then\n          csview {}\n        elif file --mime-type {} | grep -qF 'inode/directory'; then\n           eza --tree --color --icons {}\n        elif file --mime-type {} | grep -qF 'inode/directory'; then\n           eza --tree --color --icons {}\n        else\n          bat --color=always {}\n        fi\n    \"\n)\necho \"$files\"\nfor file in $files; do\n    setsid -f xdg-open $file\ndone"
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software",
    "section": "",
    "text": "An R package to analyse Seahorse data.\n    \n\n\n\nAn R package to query and summarize BED files fast\n\n\n\n\nAn R package to infer chromatin compartments from scRNA/scATAC data."
  },
  {
    "objectID": "software.html#r",
    "href": "software.html#r",
    "title": "Software",
    "section": "",
    "text": "An R package to analyse Seahorse data.\n    \n\n\n\nAn R package to query and summarize BED files fast\n\n\n\n\nAn R package to infer chromatin compartments from scRNA/scATAC data."
  },
  {
    "objectID": "posts/libdeflate.html",
    "href": "posts/libdeflate.html",
    "title": "bases or bytes?",
    "section": "",
    "text": "While looking for htslib sources that didn’t require admin rights, I tried the htslib from conda. Running the benchmarks again I saw that iscream got a lot faster, up to twice as fast in some cases, with the conda htslib compared to the htslib I was using on our HPC. I couldn’t figure out why and, after a lot of searching, I re-read the INSTALL manual which said\n\nlibdeflate (optional, but strongly recommended for faster gzip)\n\nExamining the htslib object file in conda I saw that it was compiled with libdeflate while the HPC htslib module was not."
  },
  {
    "objectID": "posts/rcpp_library.html",
    "href": "posts/rcpp_library.html",
    "title": "Using external libraries with Rcpp",
    "section": "",
    "text": "Developing R packages using Rcpp does not generally require using external libraries. When you do need them, they’re usually available as R packages like RcppEigen, RcppArmadillo which take care of linking header files correctly. I’ve been working on iscream, a package to read data from BED files by genomic region. Currently the Rsamtools package from Bioconductor provides a way to do this powered by the Rhtslib package. Rhtslib bundles the htslib C library used to work on sequencing files like SAM, BAM, and BED.\nBED files contain genomic region information and are usually stored compressed. htslib provides a way to query records from these compressed files given a set of regions. While Rsamtools can do this in R, it returns raw strings without parsing them. It also requires a GenomicRanges object so a BED file in data frame format, or a vector of region string could not be used directly. I didn’t want to use Rhtslib since it tends to update very slowly and I wanted a htslib that was more up-to-date. I was also unsure if having a Bioconductor dependency would make a CRAN submission harder.\nAt first I just used a nix shell hook to set htslib library and object paths as environment variables\n...\nin mkShell {\n  nativeBuildInputs = [\n    ...\n];\nshellHook = ''\nexport I_R=${pkgs.R}/lib/R/include/\nshellHook = ''\n  export I_HTSLIB=${pkgs.htslib}/include/\n  export L_HTSLIB=${pkgs.htslib}/lib/libhts.a\n  export L_CURL=${pkgs.curl.out}/lib/libcurl.so\n...\n''\nand hardcoded the required paths in Makevars:\nPKG_CPPFLAGS=-I $(I_HTSLIB)\nPKG_LIBS=$(L_HTSLIB) $(L_CURL) $(SHLIB_OPENMP_CXXFLAGS)\nPKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS)\nThis was obviously temporary since the flags are specific to the nix htslib package. I then learned to use pkg-config to pass htslib include flags to Makevars to compile and install the package:\nPKG_CPPFLAGS=`pkg-config --cflags htslib`\nPKG_LIBS=`pkg-config --libs htslib` $(SHLIB_OPENMP_CXXFLAGS)\nPKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS)\nI then found the curl package which uses a configure script to find, verify and use a system library. I could now find and create the Makevars file dynamically using a Makevars.in:\nCXX_STD=CXX17\nPKG_CPPFLAGS=@cflags@\nPKG_LIBS=@libs@ $(SHLIB_OPENMP_CXXFLAGS)\nPKG_CXXFLAGS=$(SHLIB_OPENMP_CXXFLAGS)\nThe configure script replaces @cflags@ and @libs@ with the correct flags."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Using external libraries with Rcpp\n\n\n\n\n\n\nR\n\nRcpp\n\nhtslib\n\n\n\n\n\n\n\n\n\nJun 10, 2025\n\n\nJames Eapen\n\n\n\n\n\n\n\n\n\n\n\n\nspotlight\n\n\nFind files, preview or open them, copy paths, drag and drop\n\n\n\ndotfiles\n\ncli\n\n\n\n\n\n\n\n\n\nAug 1, 2023\n\n\nJames Eapen\n\n\n\n\n\n\n\n\n\n\n\n\nvimmy\n\n\nWill type outside vim so you don’t have to\n\n\n\ndotfiles\n\ncli\n\n\n\n\n\n\n\n\n\nAug 1, 2023\n\n\nJames Eapen\n\n\n\n\n\nNo matching items"
  }
]